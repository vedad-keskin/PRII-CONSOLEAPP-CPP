#include <iostream>
#include <string>
#include <regex>
#include <mutex>
#include <thread>
#include <vector>
#include <fstream>
#include <memory>

#include <ctime> // iz sistema dobiti vrijeme 
#include <sstream>

using namespace std;

char* AlocirajTekst(const char* tekst) {
	if (!tekst) return nullptr;
	size_t vel = strlen(tekst) + 1;
	char* temp = new char[vel];
	strcpy_s(temp, vel, tekst);
	return temp;
}

string crt = "\n---------------------------------------------------------------------------------\n";
string PORUKA_TELEFON = crt + "TELEFONE ISKLJUCITE I ODLOZITE U TORBU, DZEP ILI DRUGU LOKACIJU VAN DOHVATA.\n"
"CESTO SE NA TELEFONIMA (PRO)NALAZE PROGRAMSKI KODOVI KOJI MOGU BITI ISKORISTENI ZA\n"
"RJESAVANJE ISPITNOG ZADATKA, STO CE, U SLUCAJU PRONALASKA, BITI SANKCIONISANO." + crt;

string PORUKA_ISPIT = crt + "0. PROVJERITE DA LI ZADACI PRIPADAJU VASOJ GRUPI (G1/G2)\n"
"1. SVE KLASE SA DINAMICKOM ALOKACIJOM MORAJU IMATI ISPRAVAN DESTRUKTOR\n"
"2. IZOSTAVLJANJE DESTRUKTORA ILI NJEGOVIH DIJELOVA BIT CE OZNACENO KAO TM\n"
"3. ATRIBUTI, METODE I PARAMETRI MORAJU BITI IDENTICNI ONIMA U TESTNOJ MAIN FUNKCIJI, "
" OSIM AKO POSTOJI JASAN RAZLOG ZA MODIFIKACIJU\n"
"4. IZUZETKE BACAJTE SAMO TAMO GDJE JE IZRICITO NAGLASENO\n"
"5. SVE METODE KOJE SE POZIVAJU U MAIN-U MORAJU POSTOJATI.\n"
" AKO NEMATE ZELJENU IMPLEMENTACIJU, OSTAVITE PRAZNO TIJELO ILI VRATITE NEKU DEFAULT VRIJEDNOST\n"
"6. RJESENJE KOPIRAJTE U .DOCX DOKUMENT (NAZIV DOKUMENTA = BROJ INDEKSA, npr.IB150051.docx)\n"
"7. NA FTP SERVER POSTAVITE SAMO .DOCX DOKUMENT, A NE CIJELI PROJEKAT\n"
"8. SVE NEDOZVOLJENE RADNJE TOKOM ISPITA BIT CE SANKCIONISANE\n"
"9. U MAIN FUNKCIJI MOZETE DODAVATI TESTNE PODATKE I POZIVE PO VLASTITOM IZBORU\n"
"10. KORISTITE VISUAL STUDIO 2022 (C++17) I TESTIRAJTE PROGRAM U OBA MODA(F5 i Ctrl + F5)\n"
"11. NA KRAJU PROVJERITE DA LI STE RJESENJE ISPITA POSTAVILI U ODGOVARAJUCI FOLDER NA FTP SERVERU" + crt;

// C++17 verzija kompajlera


enum Kategorija { ELEKTRONIKA, KNJIGE, MODA, PREHRANA };
const char* KategorijaNazivi[] = { "ELEKTRONIKA", "KNJIGE", "MODA",
"PREHRANA" };

ostream& operator << (ostream& COUT, const Kategorija& obj) {

	COUT << KategorijaNazivi[obj] ;

	return COUT;
}

	//funkcija za generisanje sifre kupca na osnovu imena i prezimena i rednog broja.
	//sifra je u formatu INICIJALI:TRENUTNA_GODINA-ID_KUPCA, npr. AB:2025-003.
	//koristiti trenutnu godinu, dobijenu iz sistema na kome se program izvrsava
	//funkciju koristiti prilikom kreiranja objekta klase Kupac za inicijalizaciju atributa _sifra

	//cout << GenerisiSifru("Amina Buric", 3) << endl; // AB:2025-003
	//cout << GenerisiSifru("Amar Macic", 15) << endl; // AM:2025-015
	//cout << GenerisiSifru("Maid Ramic", 156) << endl; // MR:2025-156
	////za validaciju sifre koristiti funkciju ValidirajSifru koja treba, koristeci regex, osigurati postivanje osnovnih pravila
	////vezanih za format koja su definisana u prethodnom dijelu zadatka.

	int GetCurrentYear() {

		time_t currentTime = time(nullptr); // ili 0
		tm localTime;
		localtime_s(&localTime, &currentTime);
	
		int fullYear = 1900 + localTime.tm_year;
		return fullYear;
	
	}

	char GetFirstLetterOfSurname(const char* imePrezime) {

	for (int i = 0; i < strlen(imePrezime); i++)
	{
		if (isspace(imePrezime[i])) {
			return imePrezime[i + 1];
		}
	}

	}

	char* GenerisiSifru(const char* imePrezime, int id) {
		
		char FirstLetterFirstName = toupper(imePrezime[0]);
		// char FirstLetterLastName = imePrezime[imePrezime.find(' ') + 1];
		char FirstLetterLastName = toupper(GetFirstLetterOfSurname(imePrezime));

		int currentYear = GetCurrentYear();

		char temp[20];

		if(id < 10) {
			sprintf_s(temp, "%c%c:%d-00%d", FirstLetterFirstName, FirstLetterLastName, currentYear, id);
		}
		else if(id < 100) {
			sprintf_s(temp, "%c%c:%d-0%d", FirstLetterFirstName, FirstLetterLastName, currentYear, id);
		}
		else {
			sprintf_s(temp, "%c%c:%d-%d", FirstLetterFirstName, FirstLetterLastName, currentYear, id);
		}

		return AlocirajTekst(temp);

	}


template<class T1, class T2, int max>
class KolekcijaParova {
	T1* _prvi[max] = { nullptr };
	T2* _drugi[max] = { nullptr };
	int _trenutno = 0;
public:

	KolekcijaParova() = default; // default -> znaci da pohranjuje defaultne parametre u postavci

	KolekcijaParova(const KolekcijaParova& obj) {

		_trenutno = obj._trenutno;

		for (int i = 0; i < _trenutno; i++)
		{

			_prvi[i] = new T1(*obj._prvi[i]);
			_drugi[i] = new T2(*obj._drugi[i]);

		}

	}

	KolekcijaParova& operator = (const KolekcijaParova& obj) {
		if (this != &obj) {

			for (int i = 0; i < _trenutno; i++)
			{
				delete _prvi[i];
				delete _drugi[i];
			}

			_trenutno = obj._trenutno;

			for (int i = 0; i < _trenutno; i++)
			{

				_prvi[i] = new T1(*obj._prvi[i]);
				_drugi[i] = new T2(*obj._drugi[i]);

			}
		}
		return *this;
	}

	void Dodaj(T1 el1, T2 el2) {

		_prvi[_trenutno] = new T1(el1);
		_drugi[_trenutno] = new T2(el2);

		_trenutno++;


	}

	//DodajNaPoziciju - dodaje par (99, Proizdovi_99) na lokaciju 1 tj.lokaciju definisanu vrijednoscu prvog parametra,
	// a vraca novo stanje kolekcije tj. kolekciju zajedno sa novododatim elementom

	//KolekcijaParova<int, string, 20> prosirenaLista = listaProizvoda.DodajNaPoziciju(1, 99, "Proizvod_99");

	KolekcijaParova DodajNaPoziciju(int lokacija, T1 el1, T2 el2) {

		KolekcijaParova prosirenaLista;

		for (int i = 0; i < _trenutno; i++)
		{
			if (i == lokacija) {

				prosirenaLista.Dodaj(el1, el2);
			}
			prosirenaLista.Dodaj(*_prvi[i], *_drugi[i]);

		}

		return prosirenaLista;

	}

	// UkloniRaspon - od lokacije definisane prvim parametrom uklanja broj elemenata definisanih drugi parametrom
	// (pocevsi od lokacije 2 ukloni 3 elementa), a vraca pokazivac na kolekciju parova s uklonjenim elementima
	//KolekcijaParova<int, string, 20>* uklonjeniProizvodi = prosirenaLista.UkloniRaspon(2, 3);

	KolekcijaParova* UkloniRaspon(int lokacijaOd, int brojElemenata) { // 1 --> iduca 3 


		if (lokacijaOd < 0 || lokacijaOd + brojElemenata > _trenutno) {

			throw exception("Opseg ne postoji");

		}

		KolekcijaParova* uklonjeniProizvodi = new KolekcijaParova(); // kolekcija3

		KolekcijaParova preostaliProizvodi; // kolekcija1

		for (int i = 0; i < _trenutno; i++)
		{

			if (i >= lokacijaOd && i < lokacijaOd + brojElemenata) {

				uklonjeniProizvodi->Dodaj(*_prvi[i], *_drugi[i]);

			}
			else {

				preostaliProizvodi.Dodaj(*_prvi[i], *_drugi[i]);

			}

		}

		*this = preostaliProizvodi;

		return uklonjeniProizvodi;

	}


	~KolekcijaParova() {
		for (int i = 0; i < _trenutno; i++) {
			delete _prvi[i]; _prvi[i] = nullptr;
			delete _drugi[i]; _drugi[i] = nullptr;
		}
	}

	int GetTrenutno() const { return _trenutno; }
	T1& GetPrvi(int indeks) { return *_prvi[indeks]; }
	T2& GetDrugi(int indeks) { return *_drugi[indeks]; }
	T1& operator[](int indeks) { return *_prvi[indeks]; }

	friend ostream& operator<<(ostream& COUT, KolekcijaParova& obj) {
		for (int i = 0; i < obj._trenutno; i++)
			COUT << obj.GetPrvi(i) << " " << obj.GetDrugi(i) << "\n";
		return COUT;
	}
};


class DatumVrijeme {
	int* _godina, * _mjesec, * _dan, * _sati, * _minute, * _sekunde;
public:
	DatumVrijeme(int dan = 1, int mjesec = 1, int godina = 2000, int
		sati = 0, int minute = 0, int sekunde = 0) {
		_godina = new int(godina);
		_mjesec = new int(mjesec);
		_dan = new int(dan);
		_sati = new int(sati);
		_minute = new int(minute);
		_sekunde = new int(sekunde);
	}

	//copy constructor
	DatumVrijeme(const DatumVrijeme& obj) {
		_godina = new int(*obj._godina);
		_mjesec = new int(*obj._mjesec);
		_dan = new int(*obj._dan);
		_sati = new int(*obj._sati);
		_minute = new int(*obj._minute);
		_sekunde = new int(*obj._sekunde);
	}

	//copy assignment operator
	DatumVrijeme& operator=(const DatumVrijeme& obj) {
		if (this != &obj) {
			delete _godina; delete _mjesec; delete _dan;
			delete _sati; delete _minute; delete _sekunde;

			_godina = new int(*obj._godina);
			_mjesec = new int(*obj._mjesec);
			_dan = new int(*obj._dan);
			_sati = new int(*obj._sati);
			_minute = new int(*obj._minute);
			_sekunde = new int(*obj._sekunde);
		}
		return *this;
		
	}

    //operator ==
	bool operator == (const DatumVrijeme& obj) const  {
		return *_godina == *obj._godina && *_mjesec == *obj._mjesec && *_dan == *obj._dan && *_sati == *obj._sati && *_minute == *obj._minute && *_sekunde == *obj._sekunde;
	}

	int toDays() {
		return *_godina * 365 + *_mjesec * 30 + *_dan;
	}

	int toSeconds()  {
		return *_sati * 3600 + *_minute * 60 + *_sekunde;
	}

	int fullCompare(){
		return toDays() * 24 * 60 * 60 + toSeconds();
	}


	~DatumVrijeme() {
		delete _godina; delete _mjesec; delete _dan;
		delete _sati; delete _minute; delete _sekunde;
		_godina = nullptr; _mjesec = nullptr; _dan = nullptr;
		_sati = nullptr; _minute = nullptr; _sekunde = nullptr;	
	}

	friend ostream& operator<<(ostream& COUT, const DatumVrijeme& obj) {
		COUT << *obj._godina << "." << *obj._mjesec << "." << *obj._dan << " " << *obj._sati << ":" << *obj._minute << ":" << *obj._sekunde;
		return COUT;
	}

};
class Proizvod {
	char* _naziv;
	Kategorija _kategorija;
	int _cijena;
public:
	Proizvod(const char* naziv = "", Kategorija kategorija = ELEKTRONIKA, int cijena = 0) : _kategorija(kategorija), _cijena(cijena) {
		_naziv = AlocirajTekst(naziv);
	}

	//copy constructor

	Proizvod(const Proizvod& obj)  {
		_naziv = AlocirajTekst(obj._naziv);
        _kategorija = obj._kategorija;
		_cijena = obj._cijena;

	}	

	//copy assignment operator
	Proizvod& operator = (const Proizvod& obj) {
		if (this != &obj) {
			delete[] _naziv;

			_naziv = AlocirajTekst(obj._naziv);
			_kategorija = obj._kategorija;
			_cijena = obj._cijena;
		}
		return *this;
	}

	// operator ==
	bool operator == (const Proizvod& obj) const {
		return strcmp(_naziv, obj._naziv) == 0 && _kategorija == obj._kategorija && _cijena == obj._cijena;
	}

	~Proizvod() { 
		delete[] _naziv;
		_naziv = nullptr;
	}


	const char* GetNaziv() const { return _naziv; }
	Kategorija GetKategorija() const { return _kategorija; }
	int GetCijena() const { return _cijena; }



	friend ostream& operator<<(ostream& COUT, const Proizvod& p) {
		COUT << p._naziv << " " << p._kategorija << " " << p._cijena;
		return COUT;
	}
};

class Transakcija {
protected:
	DatumVrijeme _vrijemeRealizacije;
	int _iznos;
public:
	Transakcija(DatumVrijeme vrijemeRealizacije, int iznos = 0)
		: _vrijemeRealizacije(vrijemeRealizacije), _iznos(iznos) {
	}

	//copy constructor
	Transakcija(const Transakcija& obj)  {
		_vrijemeRealizacije = obj._vrijemeRealizacije;
		_iznos = obj._iznos;
	}
	
	//copy assignment operator
	Transakcija& operator = (const Transakcija& obj) {
		if (this != &obj) {
			_vrijemeRealizacije = obj._vrijemeRealizacije;
			_iznos = obj._iznos;
		}
		return *this;
	}

	//operator ==
	bool operator == (const Transakcija& obj) {
		return _vrijemeRealizacije == obj._vrijemeRealizacije && _iznos == obj._iznos;
	}

	virtual ~Transakcija() {}
	virtual string Info() const = 0;

	virtual Transakcija* Clone() const = 0;

	const DatumVrijeme& GetVrijemeRealizacije() const {
		return
			_vrijemeRealizacije;
	}
	int GetIznos() const { return _iznos; }

	friend ostream& operator<<(ostream& COUT, const Transakcija& t) {
		COUT << t._vrijemeRealizacije << " " << t._iznos;
		return COUT;
	}
};

class Kupovina : public Transakcija {
	vector<Proizvod> _kupljeniProizvodi;
public:
	Kupovina(DatumVrijeme vrijemeRealizacije) :
		Transakcija(vrijemeRealizacije, 0) {
	}

	//copy constructor
	Kupovina(const Kupovina& obj) : Transakcija(obj) {
		_kupljeniProizvodi = obj._kupljeniProizvodi;
	}
	
	//copy assignment operator
	Kupovina& operator = (const Kupovina& obj) {
		if (this != &obj) {
			Transakcija::operator=(obj);
			_kupljeniProizvodi = obj._kupljeniProizvodi;
		}
		return *this;
	}

	//operator ==
	bool operator == (const Kupovina& obj) {
		return _vrijemeRealizacije == obj._vrijemeRealizacije && _iznos == obj._iznos;
	}

	string Info() const{

        stringstream ss;
		ss << *this;
		return ss.str();

	}
	
	Transakcija* Clone() const{

		return new Kupovina(*this);

	}

	bool DodajProizvod(Proizvod proizvod) {

		for (int i = 0; i < _kupljeniProizvodi.size(); i++)
		{
			if (proizvod == _kupljeniProizvodi[i]) {

				return false;

			}

		}


		_kupljeniProizvodi.push_back(proizvod);
		_iznos += proizvod.GetCijena();

		return true;

	}

	const vector<Proizvod>& GetProizvodi() const {
		return
			_kupljeniProizvodi;
	}

 	//05.10.2025 09:30:00 KUPLJENO 1 PROIZVODA U UKUPNOM IZNOSU OD 1500KM
	friend ostream& operator<<(ostream& COUT, const Kupovina& obj) {

		COUT << obj._vrijemeRealizacije << " KUPLJENO " << obj._kupljeniProizvodi.size() << " PROIZVODA U UKUPNOM IZNOSU OD " << obj._iznos << "KM";

		return COUT;
	}

};

class Povrat : public Transakcija {
	vector<Proizvod> _vraceniProizvodi;
public:
	Povrat(DatumVrijeme vrijemeRealizacije) :
		Transakcija(vrijemeRealizacije, 0) {
	}

	//copy constructor
	Povrat(const Povrat& obj) : Transakcija(obj) {
		_vraceniProizvodi = obj._vraceniProizvodi;
	}
	
	//copy assignment operator
	Povrat& operator = (const Povrat& obj) {
		if (this != &obj) {
			Transakcija::operator=(obj);
			_vraceniProizvodi = obj._vraceniProizvodi;
		}
		return *this;
	}

	//operator ==
	bool operator == (const Povrat& obj) {
		return _vrijemeRealizacije == obj._vrijemeRealizacije && _iznos == obj._iznos;
	}

	const vector<Proizvod>& GetProizvodi() const {
		return
			_vraceniProizvodi;
	}

	string Info() const{
		stringstream ss;
		ss << *this;
		return ss.str();
	}

	Transakcija* Clone() const{
		return new Povrat(*this);
	}

	vector<Proizvod>& GetVraceniProizvodi() { return _vraceniProizvodi; }


	bool DodajProizvod(Proizvod proizvod) {

		for (int i = 0; i < _vraceniProizvodi.size(); i++)
		{
			if (proizvod == _vraceniProizvodi[i]) {

				return false;

			}

		}

		_vraceniProizvodi.push_back(proizvod);
		_iznos += proizvod.GetCijena();

		return true;
	}

	friend ostream& operator<<(ostream& COUT, const Povrat& obj) {
		COUT << obj._vrijemeRealizacije << " VRACENO " << obj._vraceniProizvodi.size() << " PROIZVODA U UKUPNOM IZNOSU OD " << obj._iznos << "KM";
		return COUT;
	}
};

class Kupac {
	static int _id;
	char* _sifra;
	char* _imePrezime;
	vector<Transakcija*> _transakcije;
public:
	Kupac(const char* imePrezime) {
		_imePrezime = AlocirajTekst(imePrezime);
		_sifra = GenerisiSifru(imePrezime, _id);
		_id++;
	}


	//copy constructor
	Kupac(const Kupac& obj) {
		_imePrezime = AlocirajTekst(obj._imePrezime);
		_sifra = GenerisiSifru(obj._imePrezime, _id);

		for (int i = 0; i < obj._transakcije.size(); i++) {
			_transakcije.push_back(obj._transakcije[i]->Clone());
		}

	}
	
	//copy assignment operator
	Kupac& operator = (const Kupac& obj) {
		if (this != &obj) {
		
			delete[] _sifra;
			delete[] _imePrezime;
			for (int i = 0; i < _transakcije.size(); i++) {
				delete _transakcije[i];
			}
			_transakcije.clear();

			_imePrezime = AlocirajTekst(obj._imePrezime);
			_sifra = GenerisiSifru(obj._imePrezime, _id);
	
			for (int i = 0; i < obj._transakcije.size(); i++) {
				_transakcije.push_back(obj._transakcije[i]->Clone());
			}
		}
		return *this;
	}

	//operator ==
	bool operator == (const Kupac& obj) {
		return strcmp(_sifra, obj._sifra) == 0;
	}

	bool DodajTransakciju(Kupovina kupovina) {

		for (int i = 0; i < _transakcije.size(); i++)
		{

			if (_transakcije[i]->GetVrijemeRealizacije() == kupovina.GetVrijemeRealizacije()) {

				return false;

			}

		}

		for (int i = 0; i < _transakcije.size(); i++)
		{

            Kupovina* kupovinaTransakcija = dynamic_cast<Kupovina*>(_transakcije[i]);

			if (kupovinaTransakcija != nullptr) {


				for (int j = 0; j < kupovinaTransakcija->GetProizvodi().size(); j++)
				{

					for (int k = 0; k < kupovina.GetProizvodi().size(); k++){

						if (kupovinaTransakcija->GetProizvodi()[j] == kupovina.GetProizvodi()[k]) {

							return false;

						}

					}

				}

			}

		}


		_transakcije.push_back(new Kupovina(kupovina));

		return true;

	}

	////povrat dozvoljen samo ako je proizvod ranije kupljen


	bool DodajTransakciju(Povrat povrat) {

		for (int i = 0; i < _transakcije.size(); i++)
		{

			Kupovina* kupovinaTransakcija = dynamic_cast<Kupovina*>(_transakcije[i]);
			
			// Check if the cast was successful
			if (kupovinaTransakcija != nullptr) {
				

				for (int j = 0; j < kupovinaTransakcija->GetProizvodi().size(); j++)
				{

					for (int k = 0; k < povrat.GetProizvodi().size(); k++)
					{
						if (kupovinaTransakcija->GetProizvodi()[j] == povrat.GetProizvodi()[k]) {

							_transakcije.push_back(new Povrat(povrat));

							return true;

						}


					}

				}

			}

	

		}

		return false;


	}


	~Kupac() {
		delete[] _sifra;
		_sifra = nullptr;
		delete[] _imePrezime;
		_imePrezime = nullptr;
		for (auto* transakcija : _transakcije) delete transakcija;
		_transakcije.clear();
	}

	const char* GetSifra() const { return _sifra; }
	const char* GetImePrezime() const { return _imePrezime; }
	vector<Transakcija*>& GetTransakcije() { return _transakcije; }

	friend ostream& operator<<(ostream& COUT, const Kupac& kupac) {
		COUT << crt << kupac._imePrezime << " [" << kupac._sifra << "]\n";

		for (int i = 0; i < kupac._transakcije.size(); i++)
			COUT << " - " << kupac._transakcije[i]->Info() << "\n";

		COUT << crt;
		return COUT;
	}
};
int Kupac::_id = 1;


class Prodavnica {
	char* _naziv;
	vector<Kupac> _kupci;
public:
	Prodavnica(const char* naziv) { _naziv = AlocirajTekst(naziv); }

	~Prodavnica() { delete[] _naziv; _naziv = nullptr; }

	Prodavnica(const Prodavnica& obj) {
		_naziv = AlocirajTekst(obj._naziv); 
		_kupci = obj._kupci;
	}

	// copy assignment operator
	Prodavnica& operator = (const Prodavnica& obj) {
		if (this != &obj) {
			delete[] _naziv;
			_naziv = AlocirajTekst(obj._naziv);
			_kupci = obj._kupci;
		}
		return *this;
	}

	// operator ==
	bool operator == (const Prodavnica& obj) {
		return strcmp(_naziv, obj._naziv) == 0;
	}

	void DodajKupca(Kupac kupac) {
		for (int i = 0; i < _kupci.size(); i++) {
			if (_kupci[i] == kupac) {
				throw exception("Kupac vec postoji");
			}
		}
		
		_kupci.push_back(kupac);
	}

	////registraciju transakcije, pored direktnog nacina - preko kupca,
	////je moguce realizovati i u okviru odredjene prodavnice koja ce pronaci kupca
	////po sifri i dodati mu transakciju proslijedjenu kao parametar.u zavisnosti od rezultata
	////izvrsenja metoda vraca true ili false (i dalje vaze pravila vezana za dodavanje transakcije)
	// if (!tehnika.RegistrujTransakcijuKupcu(amina.GetSifra(), kupovinaSlusalice))
	// 	cout << "Transakcija registrovana\n";

bool RegistrujTransakcijuKupcu(const char* sifra, Kupovina kupovina) {
	for (int i = 0; i < _kupci.size(); i++) {
		if (_kupci[i].GetSifra() == sifra) {
			return _kupci[i].DodajTransakciju(kupovina) ? true : false;
		}
	}

	return false;
}

	//vraca listu svih kupaca iz prodavnice koji su imali najmanje jednu transakciju u proslijedjenoj kategoriji,
	//te koliko su ukupno potrosili na proizvode iz te kategorije (ukupna potrosnja za kategoriju se
	// izracunava: kupovina - povrat)

	//KolekcijaParova<Kupac, int, 50> potrosnja = tehnika.PotrosnjaPoKategoriji(ELEKTRONIKA);

	//for (int i = 0; i < potrosnja.GetTrenutno(); i++)
	//	cout << potrosnja.GetPrvi(i).GetImePrezime() << " [" << potrosnja.GetPrvi(i).GetSifra() << "] " << " potrosio/la " << potrosnja.GetDrugi(i) << " KM na proizvode iz kategorije ELEKTRONIKA" << crt;

	KolekcijaParova<Kupac, int, 50> PotrosnjaPoKategoriji(Kategorija kategorija) {
		KolekcijaParova<Kupac, int, 50> potrosnja;
	
		for (int i = 0; i < _kupci.size(); i++) {
			int ukupnaPotrosnja = 0;
			bool imaTransakciju = false;
	
			// Proci kroz sve transakcije kupca
			for (int j = 0; j < _kupci[i].GetTransakcije().size(); j++) {
	
				// Dodavanje nakon kupovina
				Kupovina* kupovinaTransakcija = dynamic_cast<Kupovina*>(_kupci[i].GetTransakcije()[j]);
				if (kupovinaTransakcija != nullptr) {
					for (int k = 0; k < kupovinaTransakcija->GetProizvodi().size(); k++) {
						if (kupovinaTransakcija->GetProizvodi()[k].GetKategorija() == kategorija) {
							ukupnaPotrosnja += kupovinaTransakcija->GetProizvodi()[k].GetCijena();
							imaTransakciju = true;
						}
					}
				}

				// Oduzimanje nakon povrata
				Povrat* povratTransakcija = dynamic_cast<Povrat*>(_kupci[i].GetTransakcije()[j]);
				if (povratTransakcija != nullptr) {
					for (int k = 0; k < povratTransakcija->GetProizvodi().size(); k++) {
						if (povratTransakcija->GetProizvodi()[k].GetKategorija() == kategorija) {
							ukupnaPotrosnja -= povratTransakcija->GetProizvodi()[k].GetCijena();
							imaTransakciju = true;
						}
					}
				}
			}

			// Dodavanje samo jednog kupca (bez duplikata)
			if (imaTransakciju) {
				potrosnja.Dodaj(_kupci[i], ukupnaPotrosnja);
			}
		}
		
		return potrosnja;
	}


	const char* GetNaziv() const { return _naziv; }
	vector<Kupac>& GetKupci() { return _kupci; }

	friend ostream& operator<<(ostream& COUT, const Prodavnica& obj) {
		COUT << obj._naziv << endl;
		for (int i = 0; i < obj._kupci.size(); i++)
			COUT << "\t" << obj._kupci[i] << endl;
		return COUT;
	}
};

const char* GetOdgovorNaPrvoPitanje() {
	cout << "Pitanje -> Pojasnite razliku izmedju virtualnih i cistih virtualnih metoda, te korelaciju virtualnih metoda sa polimorfizmom (navesti kratki primjer) ? \n";
		return "Odgovor -> OVDJE UNESITE VAS ODGOVOR";
}
const char* GetOdgovorNaDrugoPitanje() {
	cout << "Pitanje -> Pojasniti razliku izmedju konstruktora kopije i move konstruktora, razlike u implementaciji, te navesti primjere implicitnog i eksplicitnog poziva ? \n";
		return "Odgovor -> OVDJE UNESITE VAS ODGOVOR";
}

int main() {
	cout << PORUKA_TELEFON; cin.get(); system("cls");
	cout << PORUKA_ISPIT; cin.get(); system("cls");
	cout << GetOdgovorNaPrvoPitanje() << endl;
	cin.get();
	cout << GetOdgovorNaDrugoPitanje() << endl;
	cin.get();
	//funkcija za generisanje sifre kupca na osnovu imena i prezimena i rednog broja.
	//sifra je u formatu INICIJALI:TRENUTNA_GODINA-ID_KUPCA, npr. AB:2025-003.
	//koristiti trenutnu godinu, dobijenu iz sistema na kome se program izvrsava
	//funkciju koristiti prilikom kreiranja objekta klase Kupac za inicijalizaciju atributa _sifra

	cout << GenerisiSifru("Amina Buric", 3) << endl; // AB:2025-003
	cout << GenerisiSifru("Amar Macic", 15) << endl; // AM:2025-015
	cout << GenerisiSifru("Maid Ramic", 156) << endl; // MR:2025-156
	////za validaciju sifre koristiti funkciju ValidirajSifru koja treba, koristeci regex, osigurati postivanje osnovnih pravila
	////vezanih za format koja su definisana u prethodnom dijelu zadatka.

	//if (ValidirajSifru("AB:2025-003"))
	//		cout << "SIFRA VALIDNA\n";
	//if (!ValidirajSifru("Ab:2025-003") && !ValidirajSifru("AB2025/003") && !ValidirajSifru("AB-003:2025"))
	//	cout << "SIFRA NIJE VALIDNA\n";

	KolekcijaParova<int, string, 20> listaProizvoda;
	for (int i = 0; i < 10; i++)
		listaProizvoda.Dodaj(i, "Proizvod_" + to_string(i));
	cout << listaProizvoda << crt;

	//DodajNaPoziciju - dodaje par (99, Proizdovi_99) na lokaciju 1 tj.lokaciju definisanu vrijednoscu prvog parametra,
	// a vraca novo stanje kolekcije tj. kolekciju zajedno sa novododatim elementom

	KolekcijaParova<int, string, 20> prosirenaLista = listaProizvoda.DodajNaPoziciju(1,99, "Proizvod_99");
	cout << prosirenaLista << crt;
	// UkloniRaspon - od lokacije definisane prvim parametrom uklanja broj elemenata definisanih drugi parametrom
	// (pocevsi od lokacije 2 ukloni 3 elementa), a vraca pokazivac na kolekciju parova s uklonjenim elementima
	KolekcijaParova<int, string, 20>* uklonjeniProizvodi = prosirenaLista.UkloniRaspon(2, 3);
	cout << "Uklonjeni:\n" << *uklonjeniProizvodi << crt;

	///*
	//Uklonjeni:
	//1 Proizvod_1
	//2 Proizvod_2
	//3 Proizvod_3
	//*/
	cout << "Preostali:\n" << prosirenaLista << crt;
	///*
	//Preostali:
	//0 Proizvod_0
	//99 Proizvod_99
	//4 Proizvod_4
	//5 Proizvod_5
	//6 Proizvod_6
	//7 Proizvod_7
	//8 Proizvod_8
	//9 Proizvod_9
	//*/

	*uklonjeniProizvodi = prosirenaLista;
	cout << "Proizvodi:\n" << *uklonjeniProizvodi << crt;
	try
	{
		//baciti izuzetak u slucaju nepostojeceg opsega
		listaProizvoda.UkloniRaspon(3, 10); // izuzetak - neispravan opseg

	}
	catch (exception& e) {
		cout << "Exception: " << e.what() << crt;
	}

	DatumVrijeme vrijeme1(5, 10, 2025, 9, 30, 0), vrijeme2(5, 10, 2025, 10, 15, 0), vrijeme3(5, 10, 2025, 12, 36, 0);

	Proizvod telefon("Telefon FITPhone", ELEKTRONIKA, 1500),
		knjiga("Napredno C++ programiranje", KNJIGE, 55),
		slusalice("Slusalice FSX", ELEKTRONIKA, 129),
		laptop("Laptop FITLx", ELEKTRONIKA, 1499);



	Kupovina kupovina1(vrijeme1), kupovinaDuplikatVremena(vrijeme1),
			kupovina2(vrijeme2), kupovinaSlusalice(vrijeme2),
			kupovinaDuplikatProizvoda(vrijeme3);

	//dodaje proizvod u listu kupljenih proizvoda i azurira iznos kupovine

	kupovina1.DodajProizvod(telefon);
	kupovina2.DodajProizvod(knjiga);

	//format povratne vrijednosti info metode
	cout << kupovina1.Info() << endl; //05.10.2025 09:30:00 KUPLJENO 1 PROIZVODA U UKUPNOM IZNOSU OD 1500KM

	Kupac amina("Amina Buric"), goran("Goran Skondric"), berun("Berun Agic");
	//// DodajTransakciju - oneomguciti dupliranje transakcija sa istim vremenom, kod kupovine onemoguciti
	//// dupliranje proizvoda, a povrat omoguciti samo ako je proizvod kupljen.U zavisnosti od rezultata izvrsenja
	//// metoda vraca true ili false


	amina.DodajTransakciju(kupovina1);
	amina.DodajTransakciju(kupovina2);



	kupovinaDuplikatProizvoda.DodajProizvod(knjiga);

	//amina je u kupovina2 vec kupila knjigu, duplikat proizvoda, onemoguciti dodavanje
	if (!amina.DodajTransakciju(kupovinaDuplikatProizvoda))
		cout << "Duplikat proizvoda\n";

	kupovinaDuplikatVremena.DodajProizvod(laptop);
	//amina je u kupovina1 vec imala transakciju u vrijeme1, duplikat vremena, onemoguciti dodavanje
	if (!amina.DodajTransakciju(kupovinaDuplikatVremena))
		cout << "Duplikat vremena\n";



	Povrat povratKnjige(vrijeme2);
	povratKnjige.DodajProizvod(knjiga);
	////format povratne vrijednosti Info metode
	cout << povratKnjige.Info() << endl; // 05.10.2025 10:15:00 VRACENO 1 PROIZVODA U UKUPNOM IZNOSU OD 55KM
	////povrat dozvoljen samo ako je proizvod ranije kupljen

	if (amina.DodajTransakciju(povratKnjige))
		cout << "Povrat uspjesno izvrsen\n";

	
	cout << amina;
	
	
	Prodavnica tehnika("Tehnika"), knjizara("Knjizara");
	tehnika.DodajKupca(amina);
	tehnika.DodajKupca(goran);
	knjizara.DodajKupca(berun);

	try {
		tehnika.DodajKupca(amina); // amina je vec dodata kao kupac
	}
	catch (exception& e) {
		cout << "Exception: " << e.what() << crt;
	}

	kupovinaSlusalice.DodajProizvod(slusalice);

	////registraciju transakcije, pored direktnog nacina - preko kupca,
	////je moguce realizovati i u okviru odredjene prodavnice koja ce pronaci kupca
	////po sifri i dodati mu transakciju proslijedjenu kao parametar.u zavisnosti od rezultata
	////izvrsenja metoda vraca true ili false (i dalje vaze pravila vezana za dodavanje transakcije)
	if (!tehnika.RegistrujTransakcijuKupcu(amina.GetSifra(), kupovinaSlusalice))
		cout << "Transakcija registrovana\n";

	vector<Prodavnica> prodavnice;
	prodavnice.push_back(tehnika);
	prodavnice.push_back(knjizara);

	for (int i = 0; i < prodavnice.size(); i++)
	{
		cout << prodavnice[i] << endl;
	}

	///*
	//	Funkcija UcitajPodatke ima zadatak ucitati podatke o prodavnicama
	//   i njihovim kupcima iz fajla cije ime se proslijedjuje kao parametar
	//	(fajl mozete pronaci zajedno sa ispitnim zadatkom). Svaka linija u
	//   fajlu treba biti u formatu "ime i prezime kupca|naziv prodavnice".
	//   Funkcija za
	//	svaki red u fajlu:
	//	- unutar vector-a, po nazivu, pronadje ranije dodatu ili
	//   kreira novu prodavnicu,
	//	- kreira novog kupca ukoliko vec nije registrovan u naznacenoj
	//   prodavnici,
	//	- dodaje kupca u naznacenu prodavnicu (onemoguciti
	//   dupliciranje kupaca u istoj prodavnici).
	//	Na kraju, sve prodavnice sa svojim kupcima se trebaju nalaziti u
	//   proslijedjenom vektoru prodavnice.
	//	Funkcija vraca true ako je ucitavanje podataka bilo uspjesno (u
	//   vector ucitan najmanje jedan podatak
	//	o prodavnici ili kupcu), a false ako se desilo nesto neocekivano
	//   ili niti jedan podatak nije ucitan.
	//	Primjer sadrzaja fajla:
	//	Emina Junuz|Tehnika";
	//	Jasmin Azemovic|Tehnika";
	//	Zanin Vejzovic|Knjizara";
	//*/

	//string nazivFajla = "podaci.txt";

	//if (UcitajPodatke(nazivFajla, prodavnice)) cout << "Ucitavanje uspjesno" << crt;

	for (auto& prodavnica : prodavnice)
		cout << prodavnica.GetNaziv() << " sa " << prodavnica.GetKupci().size() << " kupaca" << crt;
	//vraca listu svih kupaca iz prodavnice koji su imali najmanje jednu transakciju u proslijedjenoj kategoriji,
	//te koliko su ukupno potrosili na proizvode iz te kategorije (ukupna potrosnja za kategoriju se
	// izracunava: kupovina - povrat)

	KolekcijaParova<Kupac, int, 50> potrosnja = tehnika.PotrosnjaPoKategoriji(ELEKTRONIKA);

	for (int i = 0; i < potrosnja.GetTrenutno(); i++)
		cout << potrosnja.GetPrvi(i).GetImePrezime() << " [" << potrosnja.GetPrvi(i).GetSifra() << "] " << " potrosio/la " << potrosnja.GetDrugi(i) << " KM na proizvode iz kategorije ELEKTRONIKA" << crt;


	cin.get();
	return 0;
}#include <iostream>

#include <vector>
#include <regex>
#include <string>

#include <thread>
#include <mutex>

#include <fstream>
#include <memory>

#include <sstream>
#include <ctime>


using namespace std;
const char* PORUKA = "\n-------------------------------------------------------------------------------\n"
"0. PROVJERITE DA LI PREUZETI ZADACI PRIPADAJU VASOJ GRUPI (G1/G2)\n"
"1. SVE KLASE TREBAJU POSJEDOVATI ADEKVATAN DESTRUKTOR\n"
"2. NAMJERNO IZOSTAVLJANJE KOMPLETNIH I/ILI POJEDINIH DIJELOVA DESTRUKTORA CE BITI OZNACENO KAO TM\n"
"3. SPASAVAJTE PROJEKAT KAKO BI SE SPRIJECILO GUBLJENJE URADJENOG ZADATKA\n"
"4. ATRIBUTI, NAZIVI METODA (SVE ISTO VAZI I ZA FUNKCIJE), TE BROJ ITIP PARAMETARA MORAJU BITI IDENTICNI "
"ONIMA KOJI SU KORISTENI U TESTNOM CODE - U, OSIM U SLUCAJU DA POSTOJI ADEKVATAN RAZLOG ZA NJIHOVU MODIFIKACIJU. "
"OSTALE POMOCNE METODE MOZETE IMENOVATI I DODAVATI PO ZELJI.\n"
"5. IZUZETAK BACITE SAMO U METODAMA U KOJIMA JE TO NAZNACENO.\n"
"6. SVE METODE POZVANE U MAIN-U ZADATKA TREBAJU POSTOJATI. UKOLIKO NISTE ZADOVOLJNI IMPLEMENTACIJOM "
"POTREBNO JE DA IMPLEMENTIRATE BAREM TIJELO TIH METODA (METODA MOZE BITI PRAZNA), "
"A AKO METODA TREBA VRATITI NEKI PODATAK ONDA MOZETE VRATITI BILO KOJU TJ.ZELJENU VRIJEDNOST ZAHTIJEVANOG TIPA.!\n"
"7. NA KRAJU ISPITA SVOJE RJESENJE KOPIRAJTE U .DOCX FAJL (IMENOVAN BROJEM INDEKSA npr.IB150051.docx)!\n"
"8. RJESENJA ZADATKA POSTAVITE NA FTP SERVER U ODGOVARAJUCI FOLDER!\n"
"9. NEMOJTE POSTAVLJATI VISUAL STUDIO PROJEKTE, VEC SAMO .DOCX FAJL SA VASIM RJESENJEM!\n"
"10.SVE NEDOZVOLJENE RADNJE TOKOM ISPITA CE BITI SANKCIONISANE!\n"
"11.ZA POTREBE TESTIRANJA, U MAIN-U, BUDITE SLOBODNI DODATI TESTNIH PODATAKA(POZIVA METODA) KOLIKO GOD SMATRATE DA JE POTREBNO!\n"
"12.ZA IZRADU ISPITNOG RJESENJA KORISTITI VISUAL STUDIO 2022 I RJESENJE TESTIRAJTE U OBA MODA(F5 i Ctrl + F5)!\n"
"13.NA KRAJU ISPITA PROVJERITE DA LI STE RJEÃ… ENJE KOPIRALI U ADEKVATAN FOLDER NA FTP SERVERU\n"
"-------------------------------------------------------------------------------\n";
const char* crt = "\n-------------------------------------------\n";
enum Drzava {
	ENGLESKA, SPANIJA, HOLANDIJA, FRANCUSKA, BOSNA_I_HERCEGOVINA
};

ostream& operator << (ostream& COUT, const Drzava& obj) {

	const char* KopijaDrzava[]{
		"ENGLESKA", "SPANIJA", "HOLANDIJA", "FRANCUSKA", "BOSNA_I_HERCEGOVINA"
	};

	COUT << KopijaDrzava[obj];

	return COUT;
}


char* GetNizKaraktera(const char* sadrzaj, bool dealociraj = false) {
	if (sadrzaj == nullptr)return nullptr;
	int vel = strlen(sadrzaj) + 1;
	char* temp = new char[vel];
	strcpy_s(temp, vel, sadrzaj);
	if (dealociraj)
		delete[]sadrzaj;
	return temp;
}

/*
Globalna funkcija GenerisiID vraca ID igraca na osnovu vrijednosti
proslijedjenih parametara. Funkcija generise
 ID sa maksimalno 4 cifre, ne racunajuci inicijale tj. prva slova
imena i prezimena.
 Podrazumijeva se da ce uvijek biti proslijedjene validne
vrijednosti parametara. Ukoliko se proslijede
 mala pocetna slova imena ili prezimena, potrebno ih je
konvertovati u velika.
 U okviru generisanog ID-a, proslijedjena cjelobrojna vrijednost
treba biti u obrnutom redoslijedu cifara.
 */



char FindFirstLetterSurname(const char* imeprezime) {

	for (int i = 0; i < strlen(imeprezime); i++)
	{
		if (isspace(imeprezime[i])) {
			return imeprezime[i + 1];
		}
	}

}

int ReverseNum(int id) {

	int temp = 0;

	while (id != 0) {

		temp *= 10;
		temp += id % 10;
		id /= 10;

	}

	return temp;

}

//cout << GenerisiID("Denis Music", 3) << endl;      //treba vratiti D000M3
//cout << GenerisiID("Jasmin Azemovic", 14) << endl; //treba vratiti J00A41
//cout << GenerisiID("Goran Skondric", 156) << endl; //treba vratiti G0S651
//cout << GenerisiID("emina junuz", 1798) << endl;   //treba vratiti EJ8971


char* GenerisiID(const char* imeprezime, int id) {

	char FirstLetterN = toupper(imeprezime[0]); // E

	//char PrvoSlovoPrezimena = toupper(imeprezime[imeprezime.find(' ') + 1]); // J 
	char FirstLetterLN = toupper(FindFirstLetterSurname(imeprezime));         // J 

	int ReversedNum = ReverseNum(id); // 41 

	char temp[10];

	if (id < 10) { // treba vratiti D000M3

		sprintf_s(temp, "%c000%c%d", FirstLetterN, FirstLetterLN, ReversedNum); // %c - char , %s - string , %d - decimal

	}
	else if (id < 100) { // treba vratiti J00A41

		sprintf_s(temp, "%c00%c%d", FirstLetterN, FirstLetterLN, ReversedNum); // %c - char , %s - string , %d - decimal

	}
	else if (id < 1000) { // treba vratiti G0S651


		sprintf_s(temp, "%c0%c%d", FirstLetterN, FirstLetterLN, ReversedNum); // %c - char , %s - string , %d - decimal

	}
	else { // treba vratiti EJ8971

		sprintf_s(temp, "%c%c%d", FirstLetterN, FirstLetterLN, ReversedNum); // %c - char , %s - string , %d - decimal

	}

	return GetNizKaraktera(temp);

}

////Za validaciju ID-a koristiti funkciju ValidirajID koja treba, koristeci regex, osigurati postivanje osnovnih pravila
////vezanih za format koja su definisana u prethodnom dijelu zadatka.

//cout << GenerisiID("Denis Music", 3) << endl;      //treba vratiti D 000M3
//cout << GenerisiID("Jasmin Azemovic", 14) << endl; //treba vratiti J 00A41
//cout << GenerisiID("Goran Skondric", 156) << endl; //treba vratiti G 0S651
//cout << GenerisiID("emina junuz", 1798) << endl;   //treba vratiti E J8971

// 1. [ ] ---> RANGE ... [A-Z] , [0-9] , [a-z] , [A-Za-z0-9] , [- ] <--- uvijek same znaci da je jedno ono sto se nalazi unutra

// 2. { } ---> VELICINA ... [A-Z]{2} , {2,5} , {5,} , {,5}

// 3. ( ) ---> TACAN TEKST ... (gmail) , (com|ba) 

bool ValidirajID(const char* ID) {

	//               D      000M3            00A41        0S651           J8971
	regex pattern("[A-Z](000[A-Z][0-9]|00[A-Z][0-9]{2}|0[A-Z][0-9]{3}|[A-Z][0-9]{4})");

	return regex_match(ID, pattern);

}

/*
Globalna funkcija GenerisiID vraca ID igraca (format: ID#00-ID) na
osnovu int vrijednosti proslijedjene
 kao parametar. Funkcija generise ID sa maksimalno 4 cifre, ne
racunajuci ostale, podrazumijevane, znakove.
 Podrazumijeva se da ce uvijek biti proslijedjena validna int
vrijednost.
 */
 //cout << GenerisiID(3) << endl;//treba vratiti ID#000-3
 //cout << GenerisiID(14) << endl;//treba vratiti ID#00-14
 //cout << GenerisiID(156) << endl;//treba vratiti ID#0-156
 //cout << GenerisiID(1798) << endl;//treba vratiti ID#1798

char* GenerisiID2(int id) {

	char temp[10];

	if (id < 10) { // treba vratiti ID#000-3

		sprintf_s(temp, "ID#000-%d", id); // %c - char , %s - string , %d - decimal

	}
	else if (id < 100) { // treba vratiti ID#00-14

		sprintf_s(temp, "ID#00-%d", id); // %c - char , %s - string , %d - decimal


	}
	else if (id < 1000) { // treba vratiti ID#0-156


		sprintf_s(temp, "ID#0-%d", id); // %c - char , %s - string , %d - decimal

	}
	else { // treba vratiti ID#1798

		sprintf_s(temp, "ID#%d", id); // %c - char , %s - string , %d - decimal

	}

	return GetNizKaraktera(temp);

}


// 1. [ ] ---> RANGE ... [A-Z] , [0-9] , [a-z] , [A-Za-z0-9] , [- ] <--- uvijek same znaci da je jedno ono sto se nalazi unutra

// 2. { } ---> VELICINA ... [A-Z]{2} , {2,5} , {5,} , {,5}

// 3. ( ) ---> TACAN TEKST ... (gmail) , (com|ba) 

//cout << GenerisiID2(3) << endl;     // treba vratiti ID# 000-3
//cout << GenerisiID2(14) << endl;    // treba vratiti ID# 00-14
//cout << GenerisiID2(156) << endl;   // treba vratiti ID# 0-156
//cout << GenerisiID2(1798) << endl;  // treba vratiti ID# 1798

bool ValidirajID2(const char* ID) {

	//             ID#   000-3       00-14          0-156         1798
	regex pattern("ID#(000-[1-9]|00-[1-9][0-9]|0-[1-9][0-9]{2}|[1-9][0-9]{3})");

	return regex_match(ID, pattern);

}



template<class T1, class T2, int max>
class Kolekcija {
	T1 _elementi1[max];
	T2 _elementi2[max];
	int* _trenutno;
public:

	Kolekcija() {

		_trenutno = new int(0);

		// ako su zadaci sa maxom ovdje ne radite nista

	}

	Kolekcija(const Kolekcija& obj) {

		_trenutno = new int(*obj._trenutno);

		for (int i = 0; i < *_trenutno; i++)
		{
			_elementi1[i] = obj._elementi1[i];
			_elementi2[i] = obj._elementi2[i];
		}

	}

	Kolekcija& operator = (const Kolekcija& obj) {
		if (this != &obj) {

			delete _trenutno;

			_trenutno = new int(*obj._trenutno);

			for (int i = 0; i < *_trenutno; i++)
			{
				_elementi1[i] = obj._elementi1[i];
				_elementi2[i] = obj._elementi2[i];
			}

		}
		return *this;
	}

	void AddElement(T1 el1, T2 el2) {


		_elementi1[*_trenutno] = el1;
		_elementi2[*_trenutno] = el2;

		(*_trenutno)++;

	}

	/* metoda InsertAt treba da doda vrijednosti prvog i drugog
parametra na lokaciju koja je definisana trecim parametrom. Povratna
vrijednost metode
 je objekat (pozivaoc metode, u konkretnom slucaju objekat
kolekcija1) u okviru koga su, na definisanu lokaciju, dodati
zahtijevani parametri.
 Nakon izvrsenja metode InsertAt, oba objekta, kolekcija1 i
kolekcija2, bi trebali posjedovati sljedeci sadrzaj:
 10 10
 0 0
 1 1
 2 2
 * ....
 */
 //Kolekcija<int, int, 10> kolekcija2 = kolekcija1.InsertAt(10, 10, 0);
 //cout << kolekcija2 << crt;

	Kolekcija InsertAt(T1 el1, T2 el2, int lokacija) { // 10 10 0 

		Kolekcija kolekcija2;

		for (int i = 0; i < *_trenutno; i++) // 0 1 2 3 4 5 6 7 8
		{
			if (i == lokacija) {

				kolekcija2.AddElement(el1, el2);

			}

			kolekcija2.AddElement(_elementi1[i], _elementi2[i]);

		}

		*this = kolekcija2; // op = 

		return kolekcija2;

	}

	/*Metoda RemoveRange prihvata lokacija OD i DO, te u tom opsegu
uklanja sve elemente iz kolekcije. U slucaju da zahtijevani opseg ne
postoji u kolekciji
 metoda treba baciti izuzetak. Na kraju, metoda treba da vrati
pokazivac na novi objekat tipa kolekcija koji sadrzi samo uklonjene
elemente

// Not the professor here, ovdje ne treba vratiti pokazivac,
// to je izgleda greska tokom pravljenja postavke za ispit ostala
	//Kolekcija<int, int, 10> kolekcija3 = kolekcija1.RemoveRange(1, 3);
	//cout << kolekcija3 << endl;
	//cout << kolekcija1 << crt;
	/*kolekcija3 bi trebala sadrzavati sljedece elemente:
	0 0
	1 1
	2 2
	dok bi kolekcija1 trebala sadrzavati sljedece elemente:
	10 10
	3 3
	4 4
	......
*/
	Kolekcija RemoveRange(int lokacijaOd, int lokacijaDo) { // 1 , 3 


		Kolekcija kolekcija3;

		Kolekcija kolekcija1;


		for (int i = 0; i < *_trenutno; i++)
		{

			if (i >= lokacijaOd && i <= lokacijaDo) { // 1 2 3 

				kolekcija3.AddElement(_elementi1[i], _elementi2[i]);

			}
			else {

				kolekcija1.AddElement(_elementi1[i], _elementi2[i]);

			}

		}

		*this = kolekcija1;


		return kolekcija3;


	}


	//Kolekcija<int, int, 10>* kolekcija3 = kolekcija1.RemoveRange(1, 3);
	//cout << *kolekcija3 << endl;
	//cout << kolekcija1 << crt;

	//Kolekcija* RemoveRange(int lokacijaOd, int lokacijaDo) { // 1 , 3 


	//	Kolekcija* kolekcija3 = new Kolekcija();

	//	Kolekcija kolekcija1;


	//	for (int i = 0; i < *_trenutno; i++)
	//	{

	//		if (i >= lokacijaOd && i <= lokacijaDo) { // 1 2 3 

	//			kolekcija3->AddElement(_elementi1[i], _elementi2[i]);

	//		}
	//		else {

	//			kolekcija1.AddElement(_elementi1[i], _elementi2[i]);

	//		}

	//	}

	//	*this = kolekcija1;


	//	return kolekcija3;


	//}

	~Kolekcija() {
		delete _trenutno; _trenutno = nullptr;
	}

	T1& getElement1(int lokacija) { return _elementi1[lokacija]; }
	T2& getElement2(int lokacija) { return _elementi2[lokacija]; }
	int getTrenutno() const { return *_trenutno; }

	friend ostream& operator<< (ostream& COUT, Kolekcija& obj) {
		for (size_t i = 0; i < *obj._trenutno; i++)
			COUT << obj.getElement1(i) << " " << obj.getElement2(i) << endl;
		return COUT;
	}
};
class Vrijeme { // Datum ili Vrijeme(Termin)
	int* _sat, * _minuta, * _sekunda;
public:
	Vrijeme(int sat = 10, int minuta = 0, int sekunda = 0) {
		_sat = new int(sat);
		_minuta = new int(minuta);
		_sekunda = new int(sekunda);
	}

	Vrijeme(const Vrijeme& obj) {

		_sat = new int(*obj._sat);
		_minuta = new int(*obj._minuta);
		_sekunda = new int(*obj._sekunda);

	}

	Vrijeme& operator = (const Vrijeme& obj) {
		if (this != &obj) {

			delete _sat;
			delete _minuta;
			delete _sekunda;

			_sat = new int(*obj._sat);
			_minuta = new int(*obj._minuta);
			_sekunda = new int(*obj._sekunda);

		}
		return *this;
	}

	bool operator == (const Vrijeme& obj) {

		return *_sat == *obj._sat && *_minuta == *obj._minuta && *_sekunda == *obj._sekunda;

	}

	int toSeconds() {

		return *_sekunda + *_minuta * 60 + *_sat * 3600;

	}

	~Vrijeme() {
		delete _sat; _sat = nullptr;
		delete _minuta; _minuta = nullptr;
		delete _sekunda; _sekunda = nullptr;
	}

	friend ostream& operator<< (ostream& COUT, const Vrijeme& obj) {
		COUT << *obj._sat << ":" << *obj._minuta << ":" << *obj._sekunda;
		return COUT;
	}
};
class Pogodak {
	Vrijeme* _vrijemePogotka;
	char* _napomena;
public:
	Pogodak(Vrijeme vrijeme, const char* napomena) {
		_napomena = GetNizKaraktera(napomena);
		_vrijemePogotka = new Vrijeme(vrijeme);
	}

	Pogodak(const Pogodak& obj) {

		_napomena = GetNizKaraktera(obj._napomena);
		_vrijemePogotka = new Vrijeme(*obj._vrijemePogotka);

	}

	Pogodak& operator = (const Pogodak& obj) {
		if (this != &obj) {

			delete[] _napomena;
			delete _vrijemePogotka;

			_napomena = GetNizKaraktera(obj._napomena);
			_vrijemePogotka = new Vrijeme(*obj._vrijemePogotka);

		}
		return *this;
	}

	bool operator == (const Pogodak& obj) {

		return *_vrijemePogotka == *obj._vrijemePogotka && strcmp(_napomena, obj._napomena) == 0;

	}

	~Pogodak() {
		delete[] _napomena; _napomena = nullptr;
		delete _vrijemePogotka; _vrijemePogotka = nullptr;
	}

	Vrijeme GetVrijemePogotka() { return *_vrijemePogotka; }
	char* GetNapomena() { return _napomena; }

	friend ostream& operator<< (ostream& COUT, const Pogodak& obj) {
		COUT << *obj._vrijemePogotka << " -> " << obj._napomena;
		return COUT;
	}
};
class Igrac {
	static int _id;
	char* _ID; // za inicijalizaciju _ID-a iskoristiti funkciju GenerisiID tj.atributa _imePrezime(inicijala imena i prezimena) i statickog clana _id
	char* _imePrezime;
	vector<Pogodak*> _pogoci;
public:
	Igrac(const char* imePrezime) {
		_imePrezime = GetNizKaraktera(imePrezime);

		_id++; // 0 --> 1 

		_ID = GenerisiID(_imePrezime, _id);

	}

	bool DodajPogodak(Pogodak pogodak) {

		for (int i = 0; i < _pogoci.size(); i++)
		{
			if (pogodak == *_pogoci[i]) {

				return false;

			}
		}

		_pogoci.push_back(new Pogodak(pogodak));

		return true;
	}

	Igrac(const Igrac& obj) {

		_ID = GetNizKaraktera(obj._ID);
		_imePrezime = GetNizKaraktera(obj._imePrezime);


		for (int i = 0; i < obj._pogoci.size(); i++)
		{
			_pogoci.push_back(new Pogodak(*obj._pogoci[i]));
		}

	}

	Igrac& operator = (const Igrac& obj) {
		if (this != &obj) {

			delete[]_ID;
			delete[]_imePrezime;
			for (size_t i = 0; i < _pogoci.size(); i++) {
				delete _pogoci[i];
			}


			_ID = GetNizKaraktera(obj._ID);
			_imePrezime = GetNizKaraktera(obj._imePrezime);


			for (int i = 0; i < obj._pogoci.size(); i++)
			{
				_pogoci.push_back(new Pogodak(*obj._pogoci[i]));
			}
		}
		return *this;
	}

	bool operator == (const Igrac& obj) {

		return strcmp(_ID, obj._ID) == 0;

	}

	~Igrac() {
		delete[]_ID; _ID = nullptr;
		delete[]_imePrezime; _imePrezime = nullptr;
		for (size_t i = 0; i < _pogoci.size(); i++) {
			delete _pogoci[i];
			_pogoci[i] = nullptr;
		}
	}

	char* GetImePrezime() { return _imePrezime; }
	char* GetID() { return _ID; }
	vector<Pogodak*>& GetPogoci() { return _pogoci; }

	friend ostream& operator<< (ostream& COUT, Igrac& obj) {
		COUT << obj._ID << " -> " << obj._imePrezime;
		for (size_t i = 0; i < obj._pogoci.size(); i++)
			cout << *obj._pogoci[i] << endl;
		return COUT;
	}
};
int Igrac::_id = 0;


class Reprezentacija {
	Drzava _drzava;
	vector<Igrac> _igraci;
public:

	Reprezentacija(Drzava drzava = BOSNA_I_HERCEGOVINA) {
		_drzava = drzava;
	}

	Reprezentacija(const Reprezentacija& obj) {

		_drzava = obj._drzava;
		_igraci = obj._igraci;

	}

	Reprezentacija& operator = (const Reprezentacija& obj) {
		if (this != &obj) {


			_drzava = obj._drzava;
			_igraci = obj._igraci;

		}
		return *this;
	}

	bool operator == (const Reprezentacija& obj) {

		return _drzava == obj._drzava;

	}

	int GetBrojGolova() {

		int ukupno = 0;

		for (int i = 0; i < _igraci.size(); i++)
		{

			for (int j = 0; j < _igraci[i].GetPogoci().size(); j++)
			{
				ukupno++;
			}

		}

		return ukupno;

	}

	void AddIgrac(Igrac igrac) {

		for (int i = 0; i < _igraci.size(); i++)
		{
			if (igrac == _igraci[i]) {

				throw exception("Igrac je vec u reprezentaciji");

			}
		}

		_igraci.push_back(igrac);

	}

	~Reprezentacija() {

	}

	Drzava GetDrzava() { return _drzava; }
	vector<Igrac>& GetIgraci() { return _igraci; }

	friend ostream& operator << (ostream& COUT, const Reprezentacija& obj) {

		COUT << obj._drzava;

		return COUT;
	}


};

mutex m;
class Prventstvo {
	Kolekcija<Reprezentacija, Reprezentacija, 20> _utakmice;
public:

	Prventstvo() {

	}

	Prventstvo(const Prventstvo& obj) {

		_utakmice = obj._utakmice;

	}

	Prventstvo& operator = (const Prventstvo& obj) {
		if (this != &obj) {


			_utakmice = obj._utakmice;

		}
		return *this;
	}

	~Prventstvo() {


	}


	Kolekcija<Reprezentacija, Reprezentacija, 20>& GetUtakmice() {
		return _utakmice;
	}

	void AddUtakmicu(Reprezentacija rep1, Reprezentacija rep2) {

		for (int i = 0; i < _utakmice.getTrenutno(); i++)
		{
			if (rep1 == _utakmice.getElement1(i) && rep2 == _utakmice.getElement2(i)) {
				throw exception("Utakmica je vec dodana");
			}
		}


		_utakmice.AddElement(rep1, rep2);

	}

	////nakon svakog evidentiranog pogotka, svim igracima te utakmice (pod pretpostavkom da su validne email adrese sa ID - ovima igraca),
	////u zasebnom thread-u, poslati email. u razmaku od 2 sekunde, sa sljedecim sadrzajem :
	///*
	//To: D000M1@euro2024.com
	//From: info@euro2024.com
	//Subject: Informacija
	// 
	//Postovani,
	// 
	//U 20:35:16 sati igrac Jasmin Azemovic je zabiljezio svoj 1 pogodak na ovoj utakmici.
    //Trenutni rezultat je:
	// 
    //BOSNA_I_HERCEGOVINA 2 : 0 ENGLESKA
	// 
    //Puno srece u nastavku susreta.
    //Neka bolji tim pobijedi.
    //*/

	void PosaljiMail(const char* svakiIgracID, Vrijeme vrijemePogotka, Igrac igracKojiJeDaoGol, Reprezentacija rep1, Reprezentacija rep2) {

		m.lock();

		cout << endl << "To: " << svakiIgracID << "@euro2024.com" << endl;
		cout << "From: info@euro2024.com" << endl;
		cout << "Subject: Informacija" << endl << endl;
		cout << "Postovani," << endl << endl;
		cout << "U " << vrijemePogotka << " sati igrac " << igracKojiJeDaoGol.GetImePrezime() << " je zabiljezio svoj " << igracKojiJeDaoGol.GetPogoci().size() << 
			" pogodak na ovoj utakmici. "<<endl;
		cout << "Trenutni rezultat je:" << endl << endl;
		cout << rep1 << " " << rep1.GetBrojGolova() << " : " << rep2.GetBrojGolova() << " " << rep2 << endl << endl;
		cout << "Puno srece u nastavku susreta." << endl;
		cout << "Neka bolji tim pobijedi." << endl;


		m.unlock();

	}


	//if (euro2024.AddPogodak(  BOSNA_I_HERCEGOVINA,  ENGLESKA,          "D000M1",      prviPogodak))
	bool AddPogodak(Reprezentacija rep1, Reprezentacija rep2, const char* IDiliIP, Pogodak pogodak) {

		// proci kroz sve utakmice

		for (int i = 0; i < _utakmice.getTrenutno(); i++)
		{

			// pronaci utakmiou gdje rep1 domacin a rep2 gost

			if (rep1 == _utakmice.getElement1(i) && rep2 == _utakmice.getElement2(i)) {


				// proci kroz sve igrace rep1

				for (int j = 0; j < _utakmice.getElement1(i).GetIgraci().size(); j++)
				{

					// pronaci igraca ciji je ID ili IP jednako IDiliIP

					if (strcmp(IDiliIP, _utakmice.getElement1(i).GetIgraci()[j].GetID()) == 0 ||
						strcmp(IDiliIP, _utakmice.getElement1(i).GetIgraci()[j].GetImePrezime()) == 0) {

						//_utakmice.getElement1(i).GetIgraci()[j].GetPogoci().push_back(new Pogodak(pogodak));

						if (!_utakmice.getElement1(i).GetIgraci()[j].DodajPogodak(pogodak)) {
							return false;
						}

						Igrac igracKojiJeDaoGol = _utakmice.getElement1(i).GetIgraci()[j];

						// proci kroz sve igrace rep1 

						for (int k = 0; k < _utakmice.getElement1(i).GetIgraci().size(); k++)
						{

							Igrac svakiIgrac = _utakmice.getElement1(i).GetIgraci()[k];

							this_thread::sleep_for(chrono::seconds(2));

							thread t1(&Prventstvo::PosaljiMail, this, svakiIgrac.GetID(), pogodak.GetVrijemePogotka(), igracKojiJeDaoGol, _utakmice.getElement1(i), _utakmice.getElement2(i));

							t1.join();


						}

						// proci kroz sve igrace rep2

						for (int k = 0; k < _utakmice.getElement2(i).GetIgraci().size(); k++)
						{

							Igrac svakiIgrac = _utakmice.getElement2(i).GetIgraci()[k];

							this_thread::sleep_for(chrono::seconds(2));

							thread t1(&Prventstvo::PosaljiMail, this, svakiIgrac.GetID(), pogodak.GetVrijemePogotka(), igracKojiJeDaoGol, _utakmice.getElement1(i), _utakmice.getElement2(i));

							t1.join();


						}




						return true;



					}
				}


				// proci kroz sve igrace rep2

				for (int j = 0; j < _utakmice.getElement2(i).GetIgraci().size(); j++)
				{

					// pronaci igraca ciji je ID ili IP jednako IDiliIP

					if (strcmp(IDiliIP, _utakmice.getElement2(i).GetIgraci()[j].GetID()) == 0 ||
						strcmp(IDiliIP, _utakmice.getElement2(i).GetIgraci()[j].GetImePrezime()) == 0) {

						//_utakmice.getElement2(i).GetIgraci()[j].GetPogoci().push_back(new Pogodak(pogodak));

						if (!_utakmice.getElement2(i).GetIgraci()[j].DodajPogodak(pogodak)) {
							return false;
						}

						Igrac igracKojiJeDaoGol = _utakmice.getElement2(i).GetIgraci()[j];

						// proci kroz sve igrace rep1 

						for (int k = 0; k < _utakmice.getElement1(i).GetIgraci().size(); k++)
						{

							Igrac svakiIgrac = _utakmice.getElement1(i).GetIgraci()[k];

							this_thread::sleep_for(chrono::seconds(2));

							thread t1(&Prventstvo::PosaljiMail, this, svakiIgrac.GetID(), pogodak.GetVrijemePogotka(), igracKojiJeDaoGol, _utakmice.getElement1(i), _utakmice.getElement2(i));

							t1.join();


						}

						// proci kroz sve igrace rep2

						for (int k = 0; k < _utakmice.getElement2(i).GetIgraci().size(); k++)
						{

							Igrac svakiIgrac = _utakmice.getElement2(i).GetIgraci()[k];

							this_thread::sleep_for(chrono::seconds(2));

							thread t1(&Prventstvo::PosaljiMail, this, svakiIgrac.GetID(), pogodak.GetVrijemePogotka(), igracKojiJeDaoGol, _utakmice.getElement1(i), _utakmice.getElement2(i));

							t1.join();


						}




						return true;



					}
				}




			}

		}


	}







	///*
	//-------------------------------------------
	//(3) BOSNA_I_HERCEGOVINA : ENGLESKA (1)
	//-------------------------------------------
	//Denis Music               Goran Skondric
	//Jasmin Azemovic
	//Jasmin Azemovic
	//-------------------------------------------
	//*/

	friend ostream& operator << (ostream& COUT, Prventstvo& obj) {


		// proci kroz sve utakmice

		for (int i = 0; i < obj._utakmice.getTrenutno(); i++)
		{
			//-------------------------------------------
			//(3) BOSNA_I_HERCEGOVINA : ENGLESKA (1)
			//-------------------------------------------

			COUT << crt << "(" << obj._utakmice.getElement1(i).GetBrojGolova() << ") " << obj._utakmice.getElement1(i) << " : " << obj._utakmice.getElement2(i) << " (" << obj._utakmice.getElement2(i).GetBrojGolova() << ")" << crt;

			//Denis Music               
			//Jasmin Azemovic
			//Jasmin Azemovic
			//                          Goran Skondric
			//-------------------------------------------

			// proci kroz igrace rep1

			for (int j = 0; j < obj._utakmice.getElement1(i).GetIgraci().size(); j++)
			{

				// proci kroz golove igraca rep1

				for (int k = 0; k < obj._utakmice.getElement1(i).GetIgraci()[j].GetPogoci().size(); k++)
				{

					COUT << obj._utakmice.getElement1(i).GetIgraci()[j].GetImePrezime() << endl;

				}

			}

			// proci kroz igrace rep2

			for (int j = 0; j < obj._utakmice.getElement2(i).GetIgraci().size(); j++)
			{

				// proci kroz golove igraca rep2

				for (int k = 0; k < obj._utakmice.getElement2(i).GetIgraci()[j].GetPogoci().size(); k++)
				{

					COUT << "                          " << obj._utakmice.getElement2(i).GetIgraci()[j].GetImePrezime() << endl;

				}

			}

			COUT << "-------------------------------------------" << endl << endl;


		}


		return COUT;
	}


	//vraca sve igrace koji su na takmicenju postigli broj pogodaka koji je veci ili jednak proslijedjenoj vrijednosti
	//vector<Igrac*> igraci = euro2024(2);
	//for (size_t i = 0; i < igraci.size(); i++)
	//	cout << igraci[i]->GetImePrezime() << endl;

	vector<Igrac*> operator () (int brPogodaka) {

		vector<Igrac*> igraci;

		// proci kroz sve utakmice

		for (int i = 0; i < _utakmice.getTrenutno(); i++)
		{
			// proci kroz igrace rep1

			for (int j = 0; j < _utakmice.getElement1(i).GetIgraci().size(); j++)
			{

				// provjeriti da li je igrac dao vise ili jednako pogodaka od proslijedjene vrijednosti

				if (_utakmice.getElement1(i).GetIgraci()[j].GetPogoci().size() >= brPogodaka) {

					igraci.push_back(new Igrac(_utakmice.getElement1(i).GetIgraci()[j]));

				}

			}

			// proci kroz igrace rep2

			for (int j = 0; j < _utakmice.getElement2(i).GetIgraci().size(); j++)
			{

				// provjeriti da li je igrac dao vise ili jednako pogodaka od proslijedjene vrijednosti

				if (_utakmice.getElement2(i).GetIgraci()[j].GetPogoci().size() >= brPogodaka) {

					igraci.push_back(new Igrac(_utakmice.getElement2(i).GetIgraci()[j]));

				}

			}


		}


		return igraci;


	}

	//Vrijeme
//	prviPogodak201633(20, 16, 33),
//	drugiPogodak202319(20, 23, 19),
//	treciPogodak205108(20, 51, 8),
//	cetvrtiPogodak210654(21, 6, 54);

//                          Vrijeme(20, 15, 15), Vrijeme(20, 24, 15));
	vector<Igrac*> operator () (Vrijeme vrijemeOd, Vrijeme vrijemeDo) {

		vector<Igrac*> igraci;

		// prolazak kroz sve utakmice

		for (int i = 0; i < _utakmice.getTrenutno(); i++)
		{
			// proci kroz igrace rep1

			for (int j = 0; j < _utakmice.getElement1(i).GetIgraci().size(); j++)
			{
				// proci kroz golove igraca rep1

				for (int k = 0; k < _utakmice.getElement1(i).GetIgraci()[j].GetPogoci().size(); k++)
				{
					Igrac igracKojiJeDaoPogodak = _utakmice.getElement1(i).GetIgraci()[j];
					Pogodak pogodak = *_utakmice.getElement1(i).GetIgraci()[j].GetPogoci()[k];

					// pronasli pogodak u datom range-u

					if (pogodak.GetVrijemePogotka().toSeconds() >= vrijemeOd.toSeconds()
						&& pogodak.GetVrijemePogotka().toSeconds() <= vrijemeDo.toSeconds()) {

						igraci.push_back(new Igrac(igracKojiJeDaoPogodak));

					}
				}
			}

			// proci kroz igrace rep2

			for (int j = 0; j < _utakmice.getElement2(i).GetIgraci().size(); j++)
			{
				// proci kroz golove igraca rep2

				for (int k = 0; k < _utakmice.getElement2(i).GetIgraci()[j].GetPogoci().size(); k++)
				{
					Igrac igracKojiJeDaoPogodak = _utakmice.getElement2(i).GetIgraci()[j];
					Pogodak pogodak = *_utakmice.getElement2(i).GetIgraci()[j].GetPogoci()[k];

					// pronasli pogodak u datom range-u

					if (pogodak.GetVrijemePogotka().toSeconds() >= vrijemeOd.toSeconds()
						&& pogodak.GetVrijemePogotka().toSeconds() <= vrijemeDo.toSeconds()) {

						igraci.push_back(new Igrac(igracKojiJeDaoPogodak));

					}
				}
			}


		}



		return igraci;
	}



};
const char* GetOdgovorNaPrvoPitanje() {
	cout << "Pitanje -> Pojasnite osnovne preduslove koji moraju biti ispunjeni da bi se realizovao polimorfizam(navesti kratki primjer) ? \n";
	return "Odgovor -> OVDJE UNESITE VAS ODGOVOR";
}
const char* GetOdgovorNaDrugoPitanje() {
	cout << "Pitanje -> Pojasnite razloge koristenja kljucnih rijeci abstract i ciste virtualne metode, te razlike izmedju njih ? \n";
	return "Odgovor -> OVDJE UNESITE VAS ODGOVOR";
}
void main() {
	cout << PORUKA;
	cin.get();
	cout << GetOdgovorNaPrvoPitanje() << endl;
	cin.get();
	cout << GetOdgovorNaDrugoPitanje() << endl;
	cin.get();
	/*
	Globalna funkcija GenerisiID vraca ID igraca na osnovu vrijednosti
   proslijedjenih parametara. Funkcija generise
	ID sa maksimalno 4 cifre, ne racunajuci inicijale tj. prva slova
   imena i prezimena.
	Podrazumijeva se da ce uvijek biti proslijedjene validne
   vrijednosti parametara. Ukoliko se proslijede
	mala pocetna slova imena ili prezimena, potrebno ih je
   konvertovati u velika.
	U okviru generisanog ID-a, proslijedjena cjelobrojna vrijednost
   treba biti u obrnutom redoslijedu cifara.
	*/

	cout << GenerisiID("Denis Music", 3) << endl;      //treba vratiti D000M3
	cout << GenerisiID("Jasmin Azemovic", 14) << endl; //treba vratiti J00A41
	cout << GenerisiID("Goran Skondric", 156) << endl; //treba vratiti G0S651
	cout << GenerisiID("emina junuz", 1798) << endl;   //treba vratiti EJ8971

	cout << GenerisiID2(3) << endl;     // treba vratiti ID#000-3
	cout << GenerisiID2(14) << endl;    // treba vratiti ID#00-14
	cout << GenerisiID2(156) << endl;   // treba vratiti ID#0-156
	cout << GenerisiID2(1798) << endl;  // treba vratiti ID#1798

	////Za validaciju ID-a koristiti funkciju ValidirajID koja treba, koristeci regex, osigurati postivanje osnovnih pravila
	////vezanih za format koja su definisana u prethodnom dijelu zadatka.
	if (ValidirajID("D000M3"))
		cout << "ID VALIDAN" << endl;
	if (ValidirajID("J00A41"))
		cout << "ID VALIDAN" << endl;
	if (!ValidirajID("G00S651"))
		cout << "ID NIJE VALIDAN" << endl;
	if (!ValidirajID("Ej8971"))
		cout << "ID NIJE VALIDAN" << endl;

	//Za validaciju ID-a koristiti funkciju ValidirajID koja treba, koristeci regex, osigurati postivanje osnovnih pravila
//vezanih za format koja su definisana u prethodnom dijelu zadatka.

	if (ValidirajID2("ID#000-3"))
		cout << "ID VALIDAN" << endl;
	if (ValidirajID2("ID#0-156"))
		cout << "ID VALIDAN" << endl;
	if (!ValidirajID2("ID#120-3"))
		cout << "ID NIJE VALIDAN" << endl;
	if (!ValidirajID2("ID#00-02"))
		cout << "ID NIJE VALIDAN" << endl;



	int kolekcijaTestSize = 9;
	Kolekcija<int, int, 10> kolekcija1;

	for (int i = 0; i < kolekcijaTestSize; i++)
		kolekcija1.AddElement(i, i);//dodaje vrijednosti u kolekciju
	cout << kolekcija1 << crt;


	/* metoda InsertAt treba da doda vrijednosti prvog i drugog
   parametra na lokaciju koja je definisana trecim parametrom. Povratna
   vrijednost metode
	je objekat (pozivaoc metode, u konkretnom slucaju objekat
   kolekcija1) u okviru koga su, na definisanu lokaciju, dodati
   zahtijevani parametri.
	Nakon izvrsenja metode InsertAt, oba objekta, kolekcija1 i
   kolekcija2, bi trebali posjedovati sljedeci sadrzaj:
	10 10
	0 0
	1 1
	2 2
	* ....
	*/
	Kolekcija<int, int, 10> kolekcija2 = kolekcija1.InsertAt(10, 10, 0);
	cout << kolekcija2 << crt;
	cout << kolekcija1 << crt;



	/*Metoda RemoveRange prihvata lokacija OD i DO, te u tom opsegu
   uklanja sve elemente iz kolekcije. U slucaju da zahtijevani opseg ne
   postoji u kolekciji
	metoda treba baciti izuzetak. Na kraju, metoda treba da vrati
   pokazivac na novi objekat tipa kolekcija koji sadrzi samo uklonjene
   elemente*/

   // Not the professor here, ovdje ne treba vratiti pokazivac, 
   // to je izgleda greska tokom pravljenja postavke za ispit ostala
	Kolekcija<int, int, 10> kolekcija3 = kolekcija1.RemoveRange(1, 3);
	cout << kolekcija3 << endl;
	cout << kolekcija1 << crt;

	//Kolekcija<int, int, 10>* kolekcija3 = kolekcija1.RemoveRange(1, 3);
	//cout << *kolekcija3 << endl;
	//cout << kolekcija1 << crt;


	/*kolekcija3 bi trebala sadrzavati sljedece elemente:
	0 0
	1 1
	2 2
	dok bi kolekcija1 trebala sadrzavati sljedece elemente:
	10 10
	3 3
	4 4
	......
	*/
	kolekcija1 = kolekcija3;
	cout << kolekcija1;
	Vrijeme
		prviPogodak201633(20, 16, 33),
		drugiPogodak202319(20, 23, 19),
		treciPogodak205108(20, 51, 8),
		cetvrtiPogodak210654(21, 6, 54);


	Igrac denis("Denis Music"), jasmin("Jasmin Azemovic"),
		goran("Goran Skondric"), adil("Adil Joldic");






	if (strcmp(denis.GetID(), "D000M1") == 0 && strcmp(jasmin.GetID(), "J000A2") == 0)
		cout << "ID se uspjesno generise!" << endl;

	Pogodak prviPogodak(prviPogodak201633, "podaci o prvom pogotku"),
		drugiPogodak(drugiPogodak202319, "podaci o drugom pogotku"),
		treciPogodak(treciPogodak205108, "podaci o trecem pogotku"),
		cetvrtiPogodak(cetvrtiPogodak210654, "podaci o cetvrtom pogotku");

	//denis.GetPogoci().push_back(new Pogodak(prviPogodak));
	//denis.DodajPogodak(drugiPogodak);

	//Igrac igracKopija = denis;

	//cout << igracKopija << endl;
	//cout << jasmin << endl;
	//cout << goran << endl;
	//cout << adil << endl;

	Reprezentacija BIH(BOSNA_I_HERCEGOVINA), ENG(ENGLESKA);
	BIH.AddIgrac(denis);
	BIH.AddIgrac(jasmin);
	ENG.AddIgrac(goran);
	ENG.AddIgrac(adil);

	try
	{
		BIH.AddIgrac(denis);//onemoguciti dodavanje istih igraca - provjeravati ID
	}
	catch (exception& obj)
	{
		cout << obj.what();
	}

	Prventstvo euro2024;
	euro2024.AddUtakmicu(BIH, ENG);
	try
	{
		euro2024.AddUtakmicu(BIH, ENG);//onemoguciti ponovne susrete drzava tokom istog prvenstva
	}
	catch (exception& obj)
	{
		cout << obj.what();
	}

	//omoguciti dodavanje pogotka po ID-u ili imenu i prezimenu
	if (euro2024.AddPogodak(BOSNA_I_HERCEGOVINA, ENGLESKA, "D000M1", prviPogodak))
		cout << "Pogodak uspjesno dodat" << endl;
	//onemoguciti dodavanje istih pogodaka
	if (!euro2024.AddPogodak(BOSNA_I_HERCEGOVINA, ENGLESKA, "Denis Music", prviPogodak))
		cout << "Pogodak NIJE uspjesno dodat" << endl;
	if (euro2024.AddPogodak(BOSNA_I_HERCEGOVINA, ENGLESKA, "J000A2", drugiPogodak))
		cout << "Pogodak uspjesno dodat" << endl;
	if (euro2024.AddPogodak(BOSNA_I_HERCEGOVINA, ENGLESKA, "Jasmin Azemovic", treciPogodak))
		cout << "Pogodak uspjesno dodat" << endl;
	if (euro2024.AddPogodak(BOSNA_I_HERCEGOVINA, ENGLESKA, "Goran Skondric", cetvrtiPogodak))
		cout << "Pogodak uspjesno dodat" << endl;

	////nakon svakog evidentiranog pogotka, svim igracima te utakmice (pod pretpostavkom da su validne email adrese sa ID - ovima igraca),
	////u zasebnom thread-u, poslati email. u razmaku od 2 sekunde, sa sljedecim sadrzajem :
	///*
	//To: D000M1@euro2024.com
	//From: info@euro2024.com
	//Subject: Informacija
	//Postovani,
	//U 20:35:16 sati igrac Jasmin Azemovic je zabiljezio svoj 1
 //  pogodak na ovoj utakmici.
	//Trenutni rezultat je:
	//BOSNA_I_HERCEGOVINA 2 : 0 ENGLESKA
	//Puno srece u nastavku susreta.
	//Neka bolji tim pobijedi.
	//*/
	////ispisuje detaljnije informacije o susretu, kako je navedeno u narednom ispisu
	cout << euro2024;
	///*
	//-------------------------------------------
	//(3) BOSNA_I_HERCEGOVINA : ENGLESKA (1)
	//-------------------------------------------
	//Denis Music Goran Skondric
	//Jasmin Azemovic
	//Jasmin Azemovic
	//-------------------------------------------
	//*/
	//vraca sve igrace koji su na takmicenju postigli broj pogodaka koji je veci ili jednak proslijedjenoj vrijednosti
	//vector<Igrac*> igraci = euro2024(2);
	//for (size_t i = 0; i < igraci.size(); i++)
	//	cout << igraci[i]->GetImePrezime() << endl;

	//////vraca sve igrace koji su na takmicenju postigli pogodak u vremenu koje se nalazi izmedju proslijedjenih vrijednosti

	//cout << crt;

	//vector<Igrac*> igraci2 = euro2024(Vrijeme(20, 15, 15), Vrijeme(20, 24, 15));

	//for (size_t i = 0; i < igraci2.size(); i++)
	//	cout << igraci2[i]->GetImePrezime() << endl;


	cin.get();
	system("pause>0");
}